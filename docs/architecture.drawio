<mxfile host="65bd71144e">
    <diagram id="UzllzLov6MiDBfOCMm3I" name="Page-1">
        <mxGraphModel dx="690" dy="2278" grid="1" gridSize="10" guides="1" tooltips="1" connect="1" arrows="1" fold="1" page="1" pageScale="1" pageWidth="850" pageHeight="1100" math="0" shadow="0">
            <root>
                <mxCell id="0"/>
                <mxCell id="1" parent="0"/>
                <mxCell id="10" style="edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="4" target="7" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="4" value="/search?langCodes=nl-BE,de-AT&amp;amp;text=*lorem*" style="text;html=1;strokeColor=none;fillColor=none;align=left;verticalAlign=middle;whiteSpace=wrap;rounded=0;fontSize=18;" parent="1" vertex="1">
                    <mxGeometry x="40" y="40" width="390" height="30" as="geometry"/>
                </mxCell>
                <mxCell id="13" style="edgeStyle=none;html=1;exitX=0.25;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="7" target="11" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="7" value="Convert to an AbstractQuery" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;" parent="1" vertex="1">
                    <mxGeometry x="90" y="110" width="290" height="60" as="geometry"/>
                </mxCell>
                <mxCell id="11" value="For each DataSource" style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;fillColor=#f5f5f5;fontColor=#333333;strokeColor=#666666;verticalAlign=top;" parent="1" vertex="1">
                    <mxGeometry x="40" y="210" width="220" height="1190" as="geometry"/>
                </mxCell>
                <mxCell id="15" style="edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="12" target="14" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="12" value="&lt;b&gt;fetch(&lt;/b&gt;AbstractQuery&lt;b&gt;)&lt;/b&gt;&lt;br&gt;Create a specific filtered and sorted query in the form of an API URL or a set of commands to search through a pre-fetched file.&lt;br&gt;&lt;br&gt;It might be that we need to get more data because we will do some filtering later. We have to think of an easy way of abstracting this. This is very source specific." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="260" y="210" width="400" height="230" as="geometry"/>
                </mxCell>
                <mxCell id="17" style="edgeStyle=none;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="14" target="16" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="14" value="&lt;b&gt;normalize(&lt;/b&gt;item&lt;b&gt;)&lt;/b&gt;&lt;br&gt;Normalize every item to https://schema.org ontology." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="260" y="480" width="400" height="120" as="geometry"/>
                </mxCell>
                <mxCell id="20" style="edgeStyle=orthogonalEdgeStyle;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="16" target="18" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="16" value="&lt;b&gt;addUniqueIdentifier(&lt;/b&gt;item&lt;b&gt;)&lt;/b&gt;&lt;br&gt;Adds a unique wordwide identfier. This will require some thinking about edge cases and the stability of the source identifiers. This should also be deterministic in a sense that all the instances of the installed software need to generate the same identifier." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="260" y="640" width="400" height="200" as="geometry"/>
                </mxCell>
                <mxCell id="19" style="edgeStyle=orthogonalEdgeStyle;html=1;exitX=1;exitY=0.5;exitDx=0;exitDy=0;entryX=1;entryY=0.5;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="18" target="12" edge="1">
                    <mxGeometry relative="1" as="geometry">
                        <Array as="points">
                            <mxPoint x="720" y="1140"/>
                            <mxPoint x="720" y="325"/>
                        </Array>
                    </mxGeometry>
                </mxCell>
                <mxCell id="23" style="edgeStyle=orthogonalEdgeStyle;html=1;exitX=0.25;exitY=1;exitDx=0;exitDy=0;fontSize=18;" parent="1" source="18" target="21" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="18" value="&lt;b&gt;filter(&lt;/b&gt;items&lt;b&gt;)&lt;/b&gt;&lt;br&gt;An API might not have code to do a startsWith or a RegEx. In memory with a bit bigger dataset than probably required we will filter more advanced cases. If it turns out we have to little data we need to call fetch again but with different pagenation parameters.&amp;nbsp;&lt;br&gt;&lt;br&gt;In this process we also need to add information to the abstract query about the specific executed query regarding the pagination state. This state is required to generate the 'next_url'. This 'next_url' is returned in the API response that we are generating so that the client can fetch the next set of results.&amp;nbsp;&lt;br&gt;&lt;br&gt;The order of incoming results of sources is important to reflect into the 'next_url' and at what item we are. Hopefully sources have support for sorting." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="260" y="880" width="400" height="520" as="geometry"/>
                </mxCell>
                <mxCell id="25" style="edgeStyle=orthogonalEdgeStyle;html=1;exitX=0.5;exitY=1;exitDx=0;exitDy=0;entryX=0.5;entryY=0;entryDx=0;entryDy=0;fontSize=18;" parent="1" source="21" target="24" edge="1">
                    <mxGeometry relative="1" as="geometry"/>
                </mxCell>
                <mxCell id="21" value="&lt;b&gt;sort(&lt;/b&gt;alI_Items&lt;b&gt;)&lt;/b&gt;&lt;br&gt;This step is not fully clear to me yet. We might have a traditional mode where we fetch everything and return it in one go. In that situation we can do sorting.&lt;br&gt;&lt;br&gt;We might also have a streaming result mode. This means that we return items as soon as they are known to us. That will mean that the client needs to adopt their interface to allow for streaming results and possible sort it there." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="40" y="1440" width="620" height="320" as="geometry"/>
                </mxCell>
                <mxCell id="24" value="&lt;b&gt;output()&lt;/b&gt;&lt;br&gt;Depending on the mode we return one response or a stream of items. We also return metadata such as the 'next_url', maybe aggregate information, development information etc." style="rounded=0;whiteSpace=wrap;html=1;fontSize=18;spacing=15;" parent="1" vertex="1">
                    <mxGeometry x="40" y="1800" width="620" height="150" as="geometry"/>
                </mxCell>
            </root>
        </mxGraphModel>
    </diagram>
</mxfile>